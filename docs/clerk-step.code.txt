'use client';
import type { TOCItemType } from 'fumadocs-core/server';
import * as Primitive from 'fumadocs-core/toc';
import { useEffect, useRef, useState } from 'react';
import { cn } from '@/utils/cn';
import { TocThumb } from '@/components/layout/toc-thumb';
import { TocItemsEmpty } from '@/components/layout/toc';

// Constants for step indicator styling
const STEP_CIRCLE_DIAMETER = 20; // px
const STEP_CIRCLE_RADIUS = STEP_CIRCLE_DIAMETER / 2;
// X-coordinate for the left edge of the circle
const STEP_CIRCLE_X_POSITION = 8; // px;
// X-coordinate for the center of the circle, where the main line passes
const STEP_LINE_CENTER_X = STEP_CIRCLE_X_POSITION + STEP_CIRCLE_RADIUS;
// Start padding for the text, after the circle and a small gap
const STEP_TEXT_START_PADDING = STEP_CIRCLE_X_POSITION + STEP_CIRCLE_DIAMETER + 8; // px

export default function ClerkTOCItems({ items }: { items: TOCItemType[] }) {
  const containerRef = useRef<HTMLDivElement>(null);

  const [svg, setSvg] = useState<{
    path: string;
    width: number;
    height: number;
  }>();

  useEffect(() => {
    if (!containerRef.current) return;
    const container = containerRef.current;

    function onResize(): void {
      if (container.clientHeight === 0) return;
      // Path generation logic updated for step-style TOC
      const linePath: string[] = [];
      let maxContentHeight = 0;

      for (let i = 0; i < items.length; i++) {
        const element: HTMLElement | null = container.querySelector(
          `a[href="#${items[i].url.slice(1)}"]`,
        );
        if (!element) continue;

        const itemCenterY = element.offsetTop + element.clientHeight / 2;
        maxContentHeight = Math.max(maxContentHeight, itemCenterY + STEP_CIRCLE_RADIUS);

        if (i === 0) {
          linePath.push(`M${STEP_LINE_CENTER_X} ${itemCenterY}`);
        } else {
          linePath.push(`L${STEP_LINE_CENTER_X} ${itemCenterY}`);
        }
      }

      if (linePath.length > 0) {
        setSvg({
          path: linePath.join(' '),
          width: STEP_LINE_CENTER_X + 2, // Ensure line is visible (+ stroke width)
          height: maxContentHeight + 2, // Ensure path fits
        });
      } else {
        setSvg(undefined);
      }
    }

    const observer = new ResizeObserver(onResize);
    onResize();

    observer.observe(container);
    return () => {
      observer.disconnect();
    };
  }, [items]);

  if (items.length === 0) return <TocItemsEmpty />;

  return (
    <>
      {svg ? (
        <div
          className="pointer-events-none absolute start-0 top-0 rtl:-scale-x-100"
          style={{
            width: svg.width,
            height: svg.height,
            maskImage: `url("data:image/svg+xml,${
              // Inline SVG
              encodeURIComponent(
                // Adjusted stroke-width for potentially thinner line
                `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${svg.width} ${svg.height}"><path d="${svg.path}" stroke="black" stroke-width="1.5" fill="none" /></svg>`,
              )
            }")`,
          }}
        >
          <TocThumb
            containerRef={containerRef}
            className="mt-[calc(var(--fd-top)_-_0px)] h-[var(--fd-height)] w-full bg-fd-primary transition-all duration-150"
          />
        </div>
      ) : null}
      <div className="flex flex-col" ref={containerRef}>
        {items.map((item, i) => (
          <TOCItem
            key={item.url}
            item={item}
            upper={items[i - 1]?.depth}
            lower={items[i + 1]?.depth}
          />
        ))}
      </div>
    </>
  );
}

function getItemOffset(depth: number, isStepItem: boolean): number {
  if (isStepItem) return STEP_TEXT_START_PADDING;
  // Original logic for non-step items (if any coexist)
  if (depth <= 2) return 14;
  if (depth === 3) return 26;
  return 36;
}

function getLineOffset(depth: number, isStepItem: boolean): number {
  if (isStepItem) return STEP_LINE_CENTER_X; // This is the center for the main SVG line
  // Original logic for non-step items (if any coexist)
  return depth >= 3 ? 10 : 0;
}

function TOCItem({
  item,
  upper = item.depth,
  lower = item.depth,
}: {
  item: TOCItemType;
  upper?: number;
  lower?: number;
}) {
  const stepMatch = item.title.match(/^(\\d+)\\s+(.*)$/); // Regex to find "1. Title" or "1 Title"
  const isStepItem = !!stepMatch;
  const stepNumber = stepMatch ? stepMatch[1] : null;
  const titleText = stepMatch ? stepMatch[2] : item.title;

  // Use updated offset functions
  const currentItemTextPadding = getItemOffset(item.depth, isStepItem);
  // lineXOffsetForCircle is where the circle's center should be relative to its container start
  const lineXOffsetForCircle = STEP_CIRCLE_X_POSITION;

  return (
    <Primitive.TOCItem
      href={item.url}
      style={{
        paddingInlineStart: currentItemTextPadding,
      }}
      className="prose relative py-1.5 text-sm text-fd-muted-foreground transition-colors [overflow-wrap:anywhere] first:pt-0 last:pb-0 data-[active=true]:text-fd-primary data-[active=true]:font-medium"
    >
      {isStepItem && stepNumber && (
        <div
          className="absolute flex items-center justify-center rounded-full bg-fd-primary text-xs font-medium text-fd-primary-foreground group-data-[active=true]:bg-fd-primary group-data-[active=true]:text-fd-primary-foreground"
          style={{
            left: lineXOffsetForCircle, // Position circle's left edge
            top: '50%',
            transform: 'translateY(-50%)',
            width: STEP_CIRCLE_DIAMETER,
            height: STEP_CIRCLE_DIAMETER,
          }}
        >
          {stepNumber}
        </div>
      )}
      {titleText}
    </Primitive.TOCItem>
  );
}
