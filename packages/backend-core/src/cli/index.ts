#!/usr/bin/env node
import { Command } from 'commander';
import { promises as fs } from 'fs';
import path from 'path';

type RouteDef = {
  path: string;
  importPath: string;
  methods: string[];
  extras?: string[];
};

const PACKAGE_NAME = '@windrun-huaiin/backend-core';

const ROUTES: RouteDef[] = [
  {
    path: 'webhook/stripe',
    importPath: `${PACKAGE_NAME}/app/api/webhook/stripe/route`,
    methods: ['POST'],
    extras: ['runtime'],
  },
  {
    path: 'webhook/clerk/user',
    importPath: `${PACKAGE_NAME}/app/api/webhook/clerk/user/route`,
    methods: ['POST'],
  },
  {
    path: 'user/anonymous/init',
    importPath: `${PACKAGE_NAME}/app/api/user/anonymous/init/route`,
    methods: ['POST'],
  },
  {
    path: 'stripe/checkout',
    importPath: `${PACKAGE_NAME}/app/api/stripe/checkout/route`,
    methods: ['POST'],
  },
  {
    path: 'stripe/customer-portal',
    importPath: `${PACKAGE_NAME}/app/api/stripe/customer-portal/route`,
    methods: ['POST'],
  },
];

const program = new Command();
program.name('backend-core').description('Backend-core helper CLI');

program
  .command('routes:sync')
  .description('Generate Next.js route proxy files that re-export backend-core handlers')
  .option('--app-dir <dir>', 'App directory containing api folder', 'app')
  .option('--force', 'Overwrite existing files', false)
  .action(async (opts) => {
    const cwd = process.cwd();
    const appDir = path.resolve(cwd, opts.appDir);
    const results: { file: string; status: string }[] = [];

    for (const route of ROUTES) {
      const targetDir = path.join(appDir, 'api', route.path);
      const targetFile = path.join(targetDir, 'route.ts');
      try {
        await fs.mkdir(targetDir, { recursive: true });
        const exists = await fileExists(targetFile);
        if (exists && !opts.force) {
          results.push({ file: targetFile, status: 'skip (exists)' });
          continue;
        }
        const content = buildProxy(route);
        await fs.writeFile(targetFile, content, 'utf8');
        results.push({ file: targetFile, status: exists ? 'overwritten' : 'created' });
      } catch (error) {
        results.push({ file: targetFile, status: `error: ${(error as Error).message}` });
      }
    }

    console.log('Routes sync results:');
    for (const r of results) {
      console.log(`- ${r.status} :: ${r.file}`);
    }
  });

program
  .command('routes:list')
  .description('List available backend-core routes')
  .action(() => {
    console.log('Available backend-core routes (relative to app/api):');
    ROUTES.forEach((route) => {
      console.log(`- ${route.path} [${route.methods.join(', ')}]`);
    });
  });

program
  .command('prisma:sync')
  .description('Append backend-core models into host prisma/schema.prisma (datasource/generator stay from host)')
  .option('--schema <file>', 'Host schema.prisma path', 'prisma/schema.prisma')
  .action(async (opts) => {
    const cwd = process.cwd();
    const hostSchemaPath = path.resolve(cwd, opts.schema);
    const pkgSchemaPath = path.resolve(getPackageRoot(), 'prisma', 'schema.prisma');

    try {
      const [hostRaw, pkgRaw] = await Promise.all([
        fs.readFile(hostSchemaPath, 'utf8'),
        fs.readFile(pkgSchemaPath, 'utf8'),
      ]);

      const hostSchemaName = extractSchemaName(hostRaw);
      const pkgModels = extractModels(pkgRaw, hostSchemaName);

      if (!pkgModels.trim()) {
        console.log('No models extracted from package schema, nothing to append.');
        return;
      }

      if (hostRaw.includes('=== backend-core models ===')) {
        console.log('Marker already found in host schema, skipping append to avoid duplicates.');
        return;
      }

      const appended = [
        hostRaw.trimEnd(),
        '',
        '// === backend-core models ===',
        pkgModels.trim(),
        '',
      ].join('\n');

      await fs.writeFile(hostSchemaPath, appended, 'utf8');
      console.log(`Appended backend-core models to ${hostSchemaPath}`);
      if (hostSchemaName && hostSchemaName !== 'nextai') {
        console.log(`Replaced @@schema("nextai") with @@schema("${hostSchemaName}")`);
      }
    } catch (error) {
      console.error('prisma:sync failed:', (error as Error).message);
      process.exitCode = 1;
    }
  });

program.parse(process.argv);

function buildProxy(route: RouteDef): string {
  const exports = [
    ...route.methods.map((method) => `export { ${method} } from '${route.importPath}';`),
    ...(route.extras?.map((name) => `export { ${name} } from '${route.importPath}';`) ?? []),
  ];
  return [
    '// Auto-generated by backend-core routes:sync',
    '// Do not edit manually unless you want to override the default handler.',
    ...exports,
    '',
  ].join('\n');
}

async function fileExists(file: string) {
  try {
    await fs.access(file);
    return true;
  } catch {
    return false;
  }
}

function getPackageRoot() {
  const __filename = new URL(import.meta.url).pathname;
  const __dirname = path.dirname(__filename);
  // dist/cli/index.js -> go up two levels to package root
  return path.resolve(__dirname, '..', '..');
}

function extractSchemaName(schema: string): string {
  // Try schema = "xxx"
  const schemaMatch = schema.match(/schema\s*=\s*"([^"]+)"/);
  if (schemaMatch) return schemaMatch[1];
  // Try schemas = ["xxx", ...]
  const schemasMatch = schema.match(/schemas\s*=\s*\[\s*"([^"]+)"/);
  if (schemasMatch) return schemasMatch[1];
  return 'nextai';
}

function extractModels(schema: string, targetSchemaName: string): string {
  // Remove generator/datasource blocks by splitting at first "model "
  const idx = schema.indexOf('model ');
  if (idx === -1) return '';
  const models = schema.slice(idx);
  return models.replace(/@@schema\("nextai"\)/g, `@@schema("${targetSchemaName}")`);
}
